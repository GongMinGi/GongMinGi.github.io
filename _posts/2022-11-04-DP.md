---
layout: single
title: "[알고리즘] 동적 계획법(Dynamic Programming)"
categories: Algorithm
author_profile: false
sidebar:
    nav: "docs"
---

# 동적 계획법(Dynamic Programming)
- 동적 계획법(dp)이란?  
	- 
	문제를 풀때 이미 푼 문제를 배열 등에 저장해 놨다가 같은 문제를 풀 때 저장해 둔 답을 제시하는 방법.
**하나의 문제를 단 한번만 풀도록 하는 알고리즘.**


- 분할 정복과 동적 계획법.
	-    
	상당수 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 같고 있다. 
물론 퀵 정렬이나 병합 정렬처럼 몇몇 요소에 대해서는 동일한 문제를 풀게되는 단점이 없기에 아주 빠른 속도를 자랑한다.
하지만, 분할 정복으로 풀게 되면 심각한 비효율성을 낳게 되는 경우가 있다. 대표적으로 피보나치 수열이다.
	- 분할 정복과 동적 계획법의 차이점
		-  공통점: 크고 어려운 문제를 잘게 나누어서 해결한 뒤 나중에 전체의 답을 구한다.
		- 차이점: 동적 계획법의 경우 이 과정에서 **메모이제이션(Memoization)** 기법을 이용해 **이미 계산한 결과를 배열에 저장함으로써 나중에 동일한 계산이 필요할 때 단순히 저장된 값을 반환**하기만 하면 된다는 차이가 있다.


- 피보나치 수열
	- 
	피보나치 수열은 특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합을 구해야 한다.
	
	- 점화식: D[i] = D[i-1] + D[i-2]
	
	공식에 따라서 1, 1, 2, 3, 5, 8, 13, ...과 같이 나아간다.   
	예를 들어 D[15]를 구하려면 D[14]와 D[13]을 알아야하고 D[14]를 구하려면 D[13]과 D[12]를 알아야한다. 이처럼 **이미 해결한 문제를 다시 반복적으로 풀어야 하기 때문에 매우 비효율적**이다.
	시간 복잡도 또한 $2^n$   으로 숫자가 커지면 처리시간이 기하급수적으로 늘어난다. n이 30정도만 되어도 사용이 거의 불가능하다.  따라서 우리는 DP를 사용한다.
```c++
// 재귀로 구현한 피보나치 수열.
int fibonacci(int x)
{
	if(x==1) return 1;
	if(x==2) return 1;
	return fibonacci(x-1) + fibonacci(x-2);
}
```

	
- 동적계획법을 사용할 수 있는 가정
	- 
	 1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
		- 피보나치 수열 처럼.
		- **단, 큰 문제와 작은 문제의 관계에서 사이클이 발생해선 안된다.**
	 2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일해야 한다.
		 - 점화식을 세울 수 있어야 한다.
		 - 4를 구하는 과정에서 구해서 저장했던 3을 5를 구하는 과정에서도 그대로 쓸 수 있는 문제여야 한다.

- DP로 피보나치 수열 구현하기
	- 

    ```c++
    int save[100];
    int DP(int x)
    {
	    if(x==1) return 1;
	    if(x==2) return 1;
	    if(save[x] != 0) return save[x];
	    return save[x] = DP(x-1) + DP(x+1);
    }
    ```
    - DP 첫 번재 방법: 재귀 하되 저장.
	    -  처음 만난 문제가 아니면, 즉, 기존에 만나서 저장했던 문제라면 if(save[x]!=0) 기존에 풀고 저장해뒀던 것을 불러오기. return save[x]
	    -  처음 만난 문제라면 return save[x] = DP(x-1) + DP(x+1)
	    -  위 부터 계산해 내려가는 **Top-Down** 방식.
	  
	 ```c++
	 int save[100];
	 int DP(int x)
	 {
		 save[0] = 0; save[1]= 1;
		 for(int i = 2; i<=n; i++)
				 save[i] = save[i - 1] + save[i - 2];
		 return save[x];
	 }
	```
	- DP 두 번째 방법: 반복문으로 처음부터 저장.
		- 아래 부터 계산해 올라가는 **Bottom-Up** 방식.

- 출처
	- 
	- https://blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221233570962&redirect=Dlog&widgetTypeCall=true&directAccess=false
		- 동빈나 님의 블로그.
	- https://ansohxxn.github.io/algorithm/dp/
		- 공부하는 식빵맘 님의 블로그.
